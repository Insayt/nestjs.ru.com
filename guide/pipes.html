<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Pipes | NestJS</title>
    <meta name="generator" content="VuePress 1.9.1">
    <script>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(87021734, "init", {
        clickmap:false,
        trackLinks:false,
        accurateTrackBounce:true
   });</script>
    <meta name="description" content="Nest js русская документация | Nest js документация на русском">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.3d05f6df.css" as="style"><link rel="preload" href="/assets/js/app.2760a578.js" as="script"><link rel="preload" href="/assets/js/2.6ffe1b8d.js" as="script"><link rel="preload" href="/assets/js/21.f5bd94c7.js" as="script"><link rel="preload" href="/assets/js/9.91b56dc7.js" as="script"><link rel="prefetch" href="/assets/js/10.0726f48d.js"><link rel="prefetch" href="/assets/js/11.ba640f3d.js"><link rel="prefetch" href="/assets/js/12.4379d3c3.js"><link rel="prefetch" href="/assets/js/13.0e564983.js"><link rel="prefetch" href="/assets/js/14.211c0dce.js"><link rel="prefetch" href="/assets/js/15.c9d206b7.js"><link rel="prefetch" href="/assets/js/16.3f382c11.js"><link rel="prefetch" href="/assets/js/17.3334c5b7.js"><link rel="prefetch" href="/assets/js/18.1148fb75.js"><link rel="prefetch" href="/assets/js/19.c676584b.js"><link rel="prefetch" href="/assets/js/20.6966a718.js"><link rel="prefetch" href="/assets/js/22.c6dfbc69.js"><link rel="prefetch" href="/assets/js/23.df016453.js"><link rel="prefetch" href="/assets/js/24.c7e4be77.js"><link rel="prefetch" href="/assets/js/3.be46b070.js"><link rel="prefetch" href="/assets/js/4.b6c6d50c.js"><link rel="prefetch" href="/assets/js/5.af6ee897.js"><link rel="prefetch" href="/assets/js/6.2ad59a3b.js"><link rel="prefetch" href="/assets/js/7.5a6a118a.js"><link rel="prefetch" href="/assets/js/8.0517e688.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3d05f6df.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.svg" alt="NestJS" class="logo"> <span class="site-name can-hide">NestJS</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/Insayt/nestjs.ru.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/Insayt/nestjs.ru.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/guide/introduction.html" class="sidebar-link">Введение</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Обзор</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/first-steps.html" class="sidebar-link">Первые шаги</a></li><li><a href="/guide/controllers.html" class="sidebar-link">Контроллеры</a></li><li><a href="/guide/providers.html" class="sidebar-link">Провайдеры</a></li><li><a href="/guide/modules.html" class="sidebar-link">Модули</a></li><li><a href="/guide/middleware.html" class="sidebar-link">Middleware</a></li><li><a href="/guide/exception-filters.html" class="sidebar-link">Фильтры исключений</a></li><li><a href="/guide/pipes.html" aria-current="page" class="active sidebar-link">Pipes</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/guide/pipes.html#встроенные-pipes" class="sidebar-link">Встроенные pipes</a></li><li class="sidebar-sub-header"><a href="/guide/pipes.html#привязка-pipe" class="sidebar-link">Привязка pipe</a></li><li class="sidebar-sub-header"><a href="/guide/pipes.html#пользовательские-pipes" class="sidebar-link">Пользовательские pipes</a></li><li class="sidebar-sub-header"><a href="/guide/pipes.html#валидация-на-основе-схемы" class="sidebar-link">Валидация на основе схемы</a></li><li class="sidebar-sub-header"><a href="/guide/pipes.html#валидация-схемы-объекта" class="sidebar-link">Валидация схемы объекта</a></li><li class="sidebar-sub-header"><a href="/guide/pipes.html#глобальные-pipes" class="sidebar-link">Глобальные pipes</a></li><li class="sidebar-sub-header"><a href="/guide/pipes.html#встроенныи-validationpipe" class="sidebar-link">Встроенный ValidationPipe</a></li><li class="sidebar-sub-header"><a href="/guide/pipes.html#использование-преобразования" class="sidebar-link">Использование преобразования</a></li></ul></li><li><a href="/guide/guards.html" class="sidebar-link">Guards</a></li><li><a href="/guide/interceptors.html" class="sidebar-link">Interceptors</a></li><li><a href="/guide/custom-decorators.html" class="sidebar-link">Пользовательские декораторы</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Основы</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/fundamentals/custom-providers.html" class="sidebar-link">Пользовательские провайдеры</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="pipes"><a href="#pipes" class="header-anchor">#</a> Pipes</h1> <p>Pipe - это класс, аннотированный декоратором <code>@Injectable()</code>. Pipe должен реализовывать интерфейс <code>PipeTransform</code>.</p> <img src="/Pipe_1.png"> <p>Pipes имеют два типичных случая использования:</p> <ul><li><strong>трансформация</strong>: преобразование входных данных в нужную форму (например, из строки в целое число).</li> <li><strong>валидация</strong>: оценить входные данные и, если они верны, просто передать их без изменений; в противном случае,
если данные неверны, выдать исключение.</li></ul> <p>В обоих случаях pipes работают с <code>аргументами</code>, обрабатываемыми <a href="/guide/controllers.html#параметры-маршрута">обработчиком маршрута контроллера</a>.
Nest устанавливает pipe непосредственно перед вызовом метода, и этот pipe получает аргументы, предназначенные для
метода, и работает с ними. Любая операция преобразования или проверки происходит в это время, после чего вызывается
обработчик маршрута с любыми (потенциально) преобразованными аргументами.</p> <p>Nest поставляется с рядом встроенных pipes, которые вы можете использовать &quot;из коробки&quot;. Вы также можете создавать свои
собственные pipes. В этой главе мы познакомимся со встроенными pipes и покажем, как привязать их к обработчикам
маршрутов. Затем мы рассмотрим несколько пользовательских pipes, чтобы показать, как можно создать их с нуля.</p> <blockquote><p>Pipes работают внутри зоны исключений. Это означает, что когда Pipe выбрасывает исключение, оно обрабатывается уровнем
исключений (глобальный фильтр исключений и любые <a href="/guide/exception-filters.html">фильтры исключений</a>, которые применяются
к текущему контексту). Учитывая вышесказанное, должно быть понятно, что когда исключение выбрасывается в Pipe,
ни один метод контроллера впоследствии не выполняется. Это дает вам наилучшую методику проверки данных, поступающих
в приложение из внешних источников.</p></blockquote> <h2 id="встроенные-pipes"><a href="#встроенные-pipes" class="header-anchor">#</a> Встроенные pipes</h2> <p>Nest поставляется с восемью pipes, доступными из коробки:</p> <ul><li><code>ValidationPipe</code></li> <li><code>ParseIntPipe</code></li> <li><code>ParseFloatPipe</code></li> <li><code>ParseBoolPipe</code></li> <li><code>ParseArrayPipe</code></li> <li><code>ParseUUIDPipe</code></li> <li><code>ParseEnumPipe</code></li> <li><code>DefaultValuePipe</code></li></ul> <p>Они экспортируются из пакета <code>@nestjs/common</code>.</p> <p>Давайте рассмотрим использование <code>ParseIntPipe</code>. Это пример использования <strong>трансформации</strong>, где pipe обеспечивает
преобразование параметра обработчика метода в целое число JavaScript (или выбрасывает исключение, если преобразование
не удалось). Позже в этой главе мы покажем простую пользовательскую реализацию для <code>ParseIntPipe</code>. Приведенные ниже
примеры также применимы к другим встроенным pipes для трансформации данных (<code>ParseBoolPipe</code>, <code>ParseFloatPipe</code>,
<code>ParseEnumPipe</code>, <code>ParseArrayPipe</code> и <code>ParseUUIDPipe</code>, которые в этой главе мы будем называть семейством <code>Parse*</code>).</p> <h2 id="привязка-pipe"><a href="#привязка-pipe" class="header-anchor">#</a> Привязка pipe</h2> <p>Чтобы использовать pipe, нам нужно привязать экземпляр класса pipe к соответствующему контексту.
В нашем примере <code>ParseIntPipe</code> мы хотим связать pipe с определенным методом обработчика маршрута и убедиться,
что он будет запущен до вызова метода. Мы сделаем это с помощью следующей конструкции, которую мы будем
называть привязкой pipe на уровне параметров метода:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">':id'</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">findOne</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> ParseIntPipe<span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Это гарантирует, что одно из следующих двух условий верно: либо параметр, который мы получаем в методе <code>findOne()</code>,
является числом (как и ожидалось в нашем вызове <code>this.catsService.findOne()</code>), либо исключение будет выброшено
до вызова обработчика маршрута.</p> <p>Например, предположим, что маршрут вызывается следующим образом:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>GET localhost:3000/abc
</code></pre></div><p>Nest выбросит исключение, подобное этому:</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;statusCode&quot;</span><span class="token operator">:</span> <span class="token number">400</span><span class="token punctuation">,</span>
  <span class="token property">&quot;message&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Validation failed (numeric string is expected)&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;error&quot;</span><span class="token operator">:</span> <span class="token string">&quot;Bad Request&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Исключение не позволит выполнить тело метода <code>findOne()</code>.</p> <p>В приведенном выше примере мы передаем класс (<code>ParseIntPipe</code>), а не экземпляр, оставляя ответственность
за инстанцирование фреймворку и обеспечивая внедрение зависимостей. Как и в случае с pipes и guards,
мы можем вместо этого передать экземпляр на месте. Передача экземпляра на месте полезна, если мы хотим настроить
поведение встроенной pipe путем передачи опций:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">':id'</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">findOne</span><span class="token punctuation">(</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ParseIntPipe</span><span class="token punctuation">(</span><span class="token punctuation">{</span> errorHttpStatusCode<span class="token operator">:</span> HttpStatus<span class="token punctuation">.</span><span class="token constant">NOT_ACCEPTABLE</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Привязка других pipe преобразования (семейство <strong>Parse*</strong>) работает аналогично. Все эти pipes работают
в контексте проверки параметров маршрута, параметров строки запроса и значений тела запроса.</p> <p>Например, с параметром строки запроса:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">findOne</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Query</span></span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> ParseIntPipe<span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Вот пример использования <code>ParseUUIDPipe</code> для разбора строкового параметра и проверки, является ли он UUID.</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">':uuid'</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">findOne</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token string">'uuid'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ParseUUIDPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> uuid<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span>uuid<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>При использовании <code>ParseUUIDPipe()</code> вы разбираете UUID версии 3, 4 или 5, если вам требуется только определенная
версия UUID, вы можете передать версию в опциях pipe.</p></blockquote> <p>Выше мы рассмотрели примеры связывания различных встроенных pipe семейства <code>Parse*</code>. Привязка pipe валидации
немного отличается; мы обсудим это в следующем разделе.</p> <blockquote><p>Также смотрите <a href="/guide/techniques/validation">Техники валидации</a> для подробных примеров pipe валидации.</p></blockquote> <h2 id="пользовательские-pipes"><a href="#пользовательские-pipes" class="header-anchor">#</a> Пользовательские pipes</h2> <p>Как уже говорилось, вы можете создавать собственные пользовательские pipes. Хотя Nest предоставляет надежные
встроенные <code>ParseIntPipe</code> и <code>ValidationPipe</code>, давайте построим простые пользовательские версии каждого из них с нуля,
чтобы увидеть, как создаются пользовательские pipes.</p> <p>Начнем с простого <code>ValidationPipe</code>. Изначально мы попросим его просто принимать входное значение и немедленно
возвращать то же значение.</p> <div class="filename">validation.pipe.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> PipeTransform<span class="token punctuation">,</span> Injectable<span class="token punctuation">,</span> ArgumentMetadata <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ValidationPipe</span> <span class="token keyword">implements</span> <span class="token class-name">PipeTransform</span> <span class="token punctuation">{</span>
  <span class="token function">transform</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> metadata<span class="token operator">:</span> ArgumentMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><code>PipeTransform&lt;T, R&gt;</code> - это общий интерфейс, который должен быть реализован любым pipe. Общий интерфейс использует <code>T</code>
для указания типа входного <code>value</code> и <code>R</code> для указания возвращаемого типа метода <code>transform()</code>.</p></blockquote> <p>Каждый pipe должнен реализовать метод <code>transform()</code> для выполнения контракта интерфейса <code>PipeTransform</code>. Этот метод
имеет два параметра:</p> <ul><li><code>value</code></li> <li><code>metadata</code></li></ul> <p>Параметр <code>value</code> - это текущий обрабатываемый аргумент метода (до его получения методом обработки маршрута),
а <code>metadata</code> - это метаданные текущего обрабатываемого аргумента метода. Объект метаданных имеет следующие свойства:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">ArgumentMetadata</span> <span class="token punctuation">{</span>
  type<span class="token operator">:</span> <span class="token string">'body'</span> <span class="token operator">|</span> <span class="token string">'query'</span> <span class="token operator">|</span> <span class="token string">'param'</span> <span class="token operator">|</span> <span class="token string">'custom'</span><span class="token punctuation">;</span>
  metatype<span class="token operator">?</span><span class="token operator">:</span> Type<span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  data<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Эти свойства описывают текущий обрабатываемый аргумент.</p> <table><tr><td><code>type</code></td> <td>Указывает, является ли аргумент телом запроса
      <code>@Body()</code>, get параметром
      <code>@Query()</code>, параметром маршрута
      <code>@Param()</code>, или пользовательским параметром (read more
      <a href="/guide/custom-decorators.html">here</a>).
    </td></tr> <tr><td><code>metatype</code></td> <td>
      Указывает метатип аргумента, например
      <code>String</code>. Примечание: значение будет равно
      <code>undefined</code> если вы либо опустите объявление типа в сигнатуре метода обработчика маршрута, либо используете ванильный JavaScript.
    </td></tr> <tr><td><code>data</code></td> <td>Строка, передаваемая декоратору, например
      <code>@Body('string')</code>. Значение будет равно
      <code>undefined</code> если оставить скобки декоратора пустыми.
    </td></tr></table> <blockquote><p>Интерфейсы TypeScript исчезают при транспиляции. Таким образом, если тип параметра метода объявлен как интерфейс,
а не как класс, значение <code>metatype</code> будет <code>Object</code>.</p></blockquote> <h2 id="валидация-на-основе-схемы"><a href="#валидация-на-основе-схемы" class="header-anchor">#</a> Валидация на основе схемы</h2> <p>Давайте сделаем наш pipe валидации немного более полезным. Рассмотрим подробнее метод <code>create()</code> контроллера
<code>CatsController</code>, где мы хотим убедиться что объект post body является валидным, прежде
чем пытаться запустить наш метод сервиса <code>CatsService</code>.</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> createCatDto<span class="token operator">:</span> CreateCatDto<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>createCatDto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Давайте сосредоточимся на параметре body <code>createCatDto</code>. Его тип - <code>CreateCatDto</code>:</p> <div class="filename">create-cat.dto.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CreateCatDto</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  breed<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Мы хотим убедиться, что любой входящий запрос к методу create содержит валидный body. Поэтому мы должны проверить
три параметра объекта <code>createCatDto</code>. Мы могли бы сделать это внутри метода обработчика маршрута, но такой подход не идеален,
поскольку он нарушит <strong>правило одной ответственности</strong> (single responsibility rule - SRP).</p> <p>Другой подход может заключаться в создании класса <strong>validator</strong> и делегировании задачи туда. Это так же не идеально, т.к.
нам придется помнить о вызове этого валидатора в начале каждого метода.</p> <p>Как насчет создания middleware для валидации? Это может сработать, но, к сожалению,
невозможно создать <strong>общий middleware</strong>, который можно использовать во всех контекстах всего приложения.
Это происходит потому, что middleware не знает о <strong>контексте выполнения</strong>, включая обработчик, который будет
вызван, и любые его параметры.</p> <p>Это, конечно, именно тот случай использования, для которого предназначены pipes. Итак, давайте продолжим и доработаем
наш pipe валидации.</p> <p class="demo">Hello this is &lt;demo-component&gt;123</p> <h2 id="валидация-схемы-объекта"><a href="#валидация-схемы-объекта" class="header-anchor">#</a> Валидация схемы объекта</h2> <p>Существует несколько подходов к проверке объектов чистым, <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener noreferrer">DRY<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
способом. Одним из распространенных подходов является использование <strong>проверки на основе схемы</strong>. Давайте попробуем
применить этот подход.</p> <p>Библиотека <a href="https://github.com/sideway/joi" target="_blank" rel="noopener noreferrer">Joi<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> позволяет создавать схемы простым способом, с читаемым API.
Давайте построим pipe валидации, который использует схемы на основе Joi.</p> <p>Начнем с установки необходимого пакета:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">npm</span> <span class="token function">install</span> --save joi
$ <span class="token function">npm</span> <span class="token function">install</span> --save-dev @types/joi
</code></pre></div><p>В приведенном ниже примере кода мы создаем простой класс, который принимает схему в качестве аргумента <code>constructor</code>.
Затем мы применяем метод <code>schema.validate()</code>, который проверяет наш входящий аргумент на соответствие предоставленной схеме.</p> <p>Как было отмечено ранее, <strong>pipe валидации</strong> либо возвращает значение без изменений, либо выбрасывает исключение.</p> <p>В следующем разделе вы увидите, как мы предоставляем соответствующую схему для данного метода контроллера с помощью
декоратора <code>@UsePipes()</code>. Это делает наш pipe валидации пригодным для повторного использования в разных контекстах,
как мы и собирались сделать.</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> PipeTransform<span class="token punctuation">,</span> Injectable<span class="token punctuation">,</span> ArgumentMetadata<span class="token punctuation">,</span> BadRequestException <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> ObjectSchema <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'joi'</span><span class="token punctuation">;</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">JoiValidationPipe</span> <span class="token keyword">implements</span> <span class="token class-name">PipeTransform</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token keyword">private</span> schema<span class="token operator">:</span> ObjectSchema<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">transform</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> metadata<span class="token operator">:</span> ArgumentMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> error <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>schema<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BadRequestException</span><span class="token punctuation">(</span><span class="token string">'Validation failed'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="привязка-pipe-валидации"><a href="#привязка-pipe-валидации" class="header-anchor">#</a> Привязка pipe валидации</h4> <p>Ранее мы рассмотрели, как связывать pipe преобразования (например, <code>ParseIntPipe</code> и остальные pipe семейства <code>Parse*</code>).</p> <p>Привязка pipe валидации также очень проста.</p> <p>В этом случае мы хотим привязать pipe на уровне вызова метода. В нашем примере для использования <code>JoiValidationPipe</code>
нам нужно сделать следующее:</p> <ol><li>Создать экземпляр <code>JoiValidationPipe</code>.</li> <li>Передать контекстно-специфическую схему Joi в конструктор класса pipe.</li> <li>Привязать pipe к методу</li></ol> <p>Мы делаем это с помощью декоратора <code>@UsePipes()</code>, как показано ниже:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">UsePipes</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JoiValidationPipe</span><span class="token punctuation">(</span>createCatSchema<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> createCatDto<span class="token operator">:</span> CreateCatDto<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>createCatDto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>Декоратор <code>@UsePipes()</code> импортируется из пакета <code>@nestjs/common</code>.</p></blockquote> <h4 id="валидатор-классов"><a href="#валидатор-классов" class="header-anchor">#</a> Валидатор классов</h4> <blockquote><p>Техники в этом разделе требуют TypeScript и недоступны, если ваше приложение написано на ванильном JavaScript.</p></blockquote> <p>Давайте рассмотрим альтернативную реализацию нашей техники валидации.</p> <p>Nest хорошо работает с библиотекой <a href="https://github.com/typestack/class-validator" target="_blank" rel="noopener noreferrer">class-validator<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. Эта мощная
библиотека позволяет использовать валидацию на основе декораторов. Валидация на основе декораторов является чрезвычайно
мощной, особенно в сочетании с возможностями <strong>Pipe</strong> в Nest, поскольку мы имеем доступ к <code>metatype</code> обрабатываемого свойства.
Прежде чем мы начнем, нам нужно установить необходимые пакеты:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">npm</span> i --save class-validator class-transformer
</code></pre></div><p>После их установки мы можем добавить несколько декораторов к классу <code>CreateCatDto</code>. Здесь мы видим значительное
преимущество этой техники: класс <code>CreateCatDto</code> остается единственным источником истины для нашего объекта Post body
(вместо того, чтобы создавать отдельный класс валидации).</p> <div class="filename">create-cat.dto.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> IsString<span class="token punctuation">,</span> IsInt <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'class-validator'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CreateCatDto</span> <span class="token punctuation">{</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">IsString</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">IsInt</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">IsString</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  breed<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>Подробнее о декораторах class-validator <a href="https://github.com/typestack/class-validator#usage" target="_blank" rel="noopener noreferrer">здесь<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p></blockquote> <p>Теперь мы можем создать класс <code>ValidationPipe</code>, который использует эти аннотации.</p> <div class="filename">validation.pipe.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> PipeTransform<span class="token punctuation">,</span> Injectable<span class="token punctuation">,</span> ArgumentMetadata<span class="token punctuation">,</span> BadRequestException <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> validate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'class-validator'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> plainToClass <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'class-transformer'</span><span class="token punctuation">;</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ValidationPipe</span> <span class="token keyword">implements</span> <span class="token class-name">PipeTransform<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">async</span> <span class="token function">transform</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> metatype <span class="token punctuation">}</span><span class="token operator">:</span> ArgumentMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>metatype <span class="token operator">||</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toValidate</span><span class="token punctuation">(</span>metatype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token function">plainToClass</span><span class="token punctuation">(</span>metatype<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> errors <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">validate</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>errors<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BadRequestException</span><span class="token punctuation">(</span><span class="token string">'Validation failed'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">private</span> <span class="token function">toValidate</span><span class="token punctuation">(</span>metatype<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> types<span class="token operator">:</span> <span class="token builtin">Function</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>String<span class="token punctuation">,</span> Boolean<span class="token punctuation">,</span> Number<span class="token punctuation">,</span> <span class="token builtin">Array</span><span class="token punctuation">,</span> Object<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">!</span>types<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>metatype<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>Выше мы использовали библиотеку <a href="https://github.com/typestack/class-transformer" target="_blank" rel="noopener noreferrer">class-transformer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.
Она создана тем же автором, что и библиотека <strong>class-validator</strong>, и в результате они очень хорошо работают вместе.</p></blockquote> <p>Давайте пройдемся по этому коду. Во-первых, обратите внимание, что метод <code>transform()</code> помечен как <code>async</code>. Это возможно
потому, что Nest поддерживает как синхронные, так и <strong>асинхронные</strong> pipe. Мы сделали этот метод <code>async</code>, потому что некоторые
проверки класса-валидатора <a href="https://github.com/typestack/class-validator#custom-validation-classes" target="_blank" rel="noopener noreferrer">могут быть async<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> (используют Promises).</p> <p>Далее обратите внимание, что мы используем деструктуризацию для извлечения поля metatype (извлечение только этого
члена из <code>ArgumentMetadata</code>) в наш параметр <code>metatype</code>. Это просто сокращение для получения полных <code>ArgumentMetadata</code>
и последующего дополнительного оператора для присвоения переменной metatype.</p> <p>Далее, обратите внимание на вспомогательную функцию <code>toValidate()</code>. Она отвечает за обход шага валидации, когда текущий
обрабатываемый аргумент является собственным типом JavaScript (к ним не могут быть подключены декораторы валидации,
поэтому нет причин пропускать их через шаг валидации).</p> <p>Далее мы используем функцию class-transformer <code>plainToClass()</code> для преобразования нашего обычного объекта аргумента
JavaScript в типизированный объект, чтобы мы могли применить валидацию. Причина, по которой мы должны это сделать,
заключается в том, что входящий объект post body, когда он десериализован из сетевого запроса, <strong>не имеет никакой
информации о типе</strong> (так работает базовая платформа, такая как Express). Class-validator должен использовать декораторы
проверки, которые мы определили для нашего DTO ранее, поэтому нам нужно выполнить это преобразование, чтобы рассматривать
входящее тело запроса как соответствующим образом оформленный объект, а не просто обычный объект.</p> <p>Наконец, как было отмечено ранее, поскольку это <strong>pipe валидации</strong>, он либо возвращает значение без изменений, либо
выбрасывает исключение.</p> <p>Последним шагом является привязка <code>ValidationPipe</code>. Pipes могут быть с привязкой к параметрам, методам, контроллерам
или глобальной привязкой. Ранее, на примере pipe валидации на основе Joi, мы видели пример привязки pipe на уровне метода.
В примере ниже мы привяжем экземпляр pipe к декоратору обработчика маршрута <code>@Body()</code>, чтобы наш pipe вызывался
для проверки тела запроса.</p> <div class="filename">cats.controller.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Post</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Body</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ValidationPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> createCatDto<span class="token operator">:</span> CreateCatDto<span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>createCatDto<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Pipes привязанные к параметрам полезны, когда логика валидации касается только одного заданного параметра.</p> <h2 id="глобальные-pipes"><a href="#глобальные-pipes" class="header-anchor">#</a> Глобальные pipes</h2> <p>Поскольку <code>ValidationPipe</code> был создан для того, чтобы быть как можно более общим, мы можем полностью реализовать
его полезность, настроив его как <strong>глобальный</strong> pipe, чтобы он применялся к каждому обработчику маршрутов во всем приложении.</p> <div class="filename">main.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">await</span> NestFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>AppModule<span class="token punctuation">)</span><span class="token punctuation">;</span>
  app<span class="token punctuation">.</span><span class="token function">useGlobalPipes</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ValidationPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">await</span> app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>В случае <a href="/guide/faq/hybrid-application">гибридных приложений</a> метод <code>useGlobalPipes()</code> не устанавливает
pipe для шлюзов и микросервисов. Для &quot;стандартных&quot; (негибридных) микросервисных приложений метод <code>useGlobalPipes()</code>
действительно монтирует pipe глобально.</p></blockquote> <p>Глобальные pipe используются во всем приложении, для каждого контроллера и каждого обработчика маршрутов.</p> <p>Обратите внимание, что с точки зрения инъекции зависимостей глобальные pipe, зарегистрированные вне какого-либо
модуля (с <code>useGlobalPipes()</code>, как в примере выше), не могут инъектировать зависимости, поскольку привязка была выполнена
вне контекста какого-либо модуля. Чтобы решить эту проблему, вы можете установить глобальный pipe <strong>непосредственно из любого модуля</strong>,
используя следующую конструкцию:</p> <div class="filename">app.module.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">APP_PIPE</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span><span class="token punctuation">;</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      provide<span class="token operator">:</span> <span class="token constant">APP_PIPE</span><span class="token punctuation">,</span>
      useClass<span class="token operator">:</span> ValidationPipe<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><blockquote><p>При использовании этого подхода для выполнения инъекции зависимостей для pipe, обратите внимание, что независимо от
модуля, в котором используется эта конструкция, pipe, по сути, является глобальным. Где это должно быть сделано?
Выберите модуль, в котором определен pipe (<code>ValidationPipe</code> в примере выше). Кроме того, <code>useClass</code> - не единственный
способ работы с регистрацией пользовательских провайдеров. Узнайте больше <a href="/guide//fundamentals/custom-providers">здесь</a>.</p></blockquote> <h2 id="встроенныи-validationpipe"><a href="#встроенныи-validationpipe" class="header-anchor">#</a> Встроенный ValidationPipe</h2> <p>Напоминаем, что вам не нужно самостоятельно создавать общий pipe валидации, поскольку <code>ValidationPipe</code> предоставляется
Nest &quot;из коробки&quot;. Встроенный <code>ValidationPipe</code> предлагает больше возможностей, чем образец,
который мы создали в этой главе и который был оставлен базовым для иллюстрации механики пользовательских pipes.
Полную информацию, а также множество примеров можно найти <a href="/guide/techniques/validation">здесь</a>.</p> <h2 id="использование-преобразования"><a href="#использование-преобразования" class="header-anchor">#</a> Использование преобразования</h2> <p>Валидация - не единственный случай использования пользовательских pipe. В начале этой главы мы упомянули, что pipe может
также <strong>преобразовывать</strong> входные данные в нужный формат. Это возможно потому, что значение, возвращаемое функцией
<code>transform</code>, полностью отменяет предыдущее значение аргумента.</p> <p>Когда это полезно? Учтите, что иногда данные, переданные от клиента, должны быть изменены - например, строка преобразуется
в целое число - прежде чем они будут правильно обработаны методом обработчика маршрута. Кроме того,
некоторые необходимые поля данных могут отсутствовать, и мы хотели бы применить значения по умолчанию.
<strong>Pipe трансформации</strong> могут выполнять эти функции, вставляя функцию обработки между запросом клиента и обработчиком запроса.</p> <p>Вот простой <code>ParseIntPipe</code>, который отвечает за разбор строки в целочисленное значение. (Как отмечалось выше, в Nest
есть встроенный <code>ParseIntPipe</code>, который является более сложным; мы включили его в качестве простого примера пользовательского
pipe трансформации).</p> <div class="filename">parse-int.pipe.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> PipeTransform<span class="token punctuation">,</span> Injectable<span class="token punctuation">,</span> ArgumentMetadata<span class="token punctuation">,</span> BadRequestException <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ParseIntPipe</span> <span class="token keyword">implements</span> <span class="token class-name">PipeTransform<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token function">transform</span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> metadata<span class="token operator">:</span> ArgumentMetadata<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> val <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">BadRequestException</span><span class="token punctuation">(</span><span class="token string">'Validation failed'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> val<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Затем мы можем привязать этот pipe к выбранному параметру, как показано ниже:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">':id'</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">findOne</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ParseIntPipe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Другим полезным случаем преобразования будет выбор <strong>существующего пользователя</strong> из базы данных, используя
идентификатор, указанный в запросе:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token string">':id'</span><span class="token punctuation">)</span>
<span class="token function">findOne</span><span class="token punctuation">(</span><span class="token decorator"><span class="token at operator">@</span><span class="token function">Param</span></span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> UserByIdPipe<span class="token punctuation">)</span> userEntity<span class="token operator">:</span> UserEntity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> userEntity<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Мы оставляем реализацию этого pipe читателю, но отметим, что, как и все другие каналы преобразования, он принимает
входное значение (<code>id</code>) и возвращает выходное значение (объект <code>UserEntity</code>). Это может сделать ваш код более декларативным
и <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener noreferrer">DRY<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, абстрагируя код запроса к БД с пользователями из вашего обработчика
в общий pipe.</p> <h4 id="предоставление-значении-по-умолчанию"><a href="#предоставление-значении-по-умолчанию" class="header-anchor">#</a> Предоставление значений по умолчанию</h4> <p>Pipes семейства <code>Parse*</code> ожидают, что значение параметра будет определено. При получении значений <code>null</code> или <code>undefined</code>
они выбрасывают исключение. Чтобы позволить конечной точке обрабатывать отсутствующие значения параметров, мы должны
предоставить значение по умолчанию, которое будет вводиться до того, как трубы <code>Parse*</code> начнут работать с этими значениями.
Для этой цели служит pipe <code>DefaultValuePipe</code>. Просто инстанцируйте <code>DefaultValuePipe</code> в декораторе <code>@Query()</code>
перед соответствующим pipe <code>Parse*</code>, как показано ниже:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">Get</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">findAll</span><span class="token punctuation">(</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Query</span></span><span class="token punctuation">(</span><span class="token string">'activeOnly'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultValuePipe</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ParseBoolPipe<span class="token punctuation">)</span> activeOnly<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">,</span>
  <span class="token decorator"><span class="token at operator">@</span><span class="token function">Query</span></span><span class="token punctuation">(</span><span class="token string">'page'</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">DefaultValuePipe</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ParseIntPipe<span class="token punctuation">)</span> page<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">{</span> activeOnly<span class="token punctuation">,</span> page <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/guide/exception-filters.html" class="prev">
        Фильтры исключений
      </a></span> <span class="next"><a href="/guide/guards.html">
        Guards
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.2760a578.js" defer></script><script src="/assets/js/2.6ffe1b8d.js" defer></script><script src="/assets/js/21.f5bd94c7.js" defer></script><script src="/assets/js/9.91b56dc7.js" defer></script>
  </body>
</html>
