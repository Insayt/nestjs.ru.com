<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Перехватчики (Interceptors) | NestJS</title>
    <meta name="generator" content="VuePress 1.9.1">
    
    <meta name="description" content="Nest js русская документация | Nest js документация на русском">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.3d05f6df.css" as="style"><link rel="preload" href="/assets/js/app.5b148a01.js" as="script"><link rel="preload" href="/assets/js/2.94dc10f7.js" as="script"><link rel="preload" href="/assets/js/17.62b50bbf.js" as="script"><link rel="preload" href="/assets/js/9.f5513680.js" as="script"><link rel="prefetch" href="/assets/js/10.86dd3639.js"><link rel="prefetch" href="/assets/js/11.be627295.js"><link rel="prefetch" href="/assets/js/12.a2d55baa.js"><link rel="prefetch" href="/assets/js/13.0e564983.js"><link rel="prefetch" href="/assets/js/14.dda9583f.js"><link rel="prefetch" href="/assets/js/15.e68e43de.js"><link rel="prefetch" href="/assets/js/16.18008346.js"><link rel="prefetch" href="/assets/js/18.a0f57113.js"><link rel="prefetch" href="/assets/js/19.8db0aa54.js"><link rel="prefetch" href="/assets/js/20.c68816f3.js"><link rel="prefetch" href="/assets/js/21.43195cf6.js"><link rel="prefetch" href="/assets/js/22.cf4bc655.js"><link rel="prefetch" href="/assets/js/23.c254b34b.js"><link rel="prefetch" href="/assets/js/24.81c38437.js"><link rel="prefetch" href="/assets/js/3.7b136418.js"><link rel="prefetch" href="/assets/js/4.10291e14.js"><link rel="prefetch" href="/assets/js/5.e7592da5.js"><link rel="prefetch" href="/assets/js/6.56c0d38b.js"><link rel="prefetch" href="/assets/js/7.55492aea.js"><link rel="prefetch" href="/assets/js/8.3079bec3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3d05f6df.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.svg" alt="NestJS" class="logo"> <span class="site-name can-hide">NestJS</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/Insayt/nestjs.ru.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/Insayt/nestjs.ru.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/guide/introduction.html" class="sidebar-link">Введение</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Обзор</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/first-steps.html" class="sidebar-link">Первые шаги</a></li><li><a href="/guide/controllers.html" class="sidebar-link">Контроллеры</a></li><li><a href="/guide/providers.html" class="sidebar-link">Провайдеры</a></li><li><a href="/guide/modules.html" class="sidebar-link">Модули</a></li><li><a href="/guide/middleware.html" class="sidebar-link">Middleware</a></li><li><a href="/guide/exception-filters.html" class="sidebar-link">Фильтры исключений</a></li><li><a href="/guide/pipes.html" class="sidebar-link">Pipes</a></li><li><a href="/guide/guards.html" class="sidebar-link">Guards</a></li><li><a href="/guide/interceptors.html" aria-current="page" class="active sidebar-link">Interceptors</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/guide/interceptors.html#основы" class="sidebar-link">Основы</a></li><li class="sidebar-sub-header"><a href="/guide/interceptors.html#контекст-исполнения" class="sidebar-link">Контекст исполнения</a></li><li class="sidebar-sub-header"><a href="/guide/interceptors.html#обработчик-вызовов" class="sidebar-link">Обработчик вызовов</a></li><li class="sidebar-sub-header"><a href="/guide/interceptors.html#детали-перехватчиков" class="sidebar-link">Детали перехватчиков</a></li><li class="sidebar-sub-header"><a href="/guide/interceptors.html#привязка-перехватчиков" class="sidebar-link">Привязка перехватчиков</a></li><li class="sidebar-sub-header"><a href="/guide/interceptors.html#маппинг-ответа" class="sidebar-link">Маппинг ответа</a></li><li class="sidebar-sub-header"><a href="/guide/interceptors.html#маппинг-исключении" class="sidebar-link">Маппинг исключений</a></li><li class="sidebar-sub-header"><a href="/guide/interceptors.html#переопределение-потоков" class="sidebar-link">Переопределение потоков</a></li><li class="sidebar-sub-header"><a href="/guide/interceptors.html#больше-операторов" class="sidebar-link">Больше операторов</a></li></ul></li><li><a href="/guide/custom-decorators.html" class="sidebar-link">Пользовательские декораторы</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Основы</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/fundamentals/custom-providers.html" class="sidebar-link">Пользовательские провайдеры</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="перехватчики-interceptors"><a href="#перехватчики-interceptors" class="header-anchor">#</a> Перехватчики (Interceptors)</h1> <p>Перехватчик - это класс, аннотированный декоратором <code>@Injectable()</code>. Перехватчики должны реализовывать интерфейс <code>NestInterceptor</code>.</p> <img src="/Interceptors_1.png"> <p>Перехватчики обладают набором полезных возможностей, которые вдохновлены техникой
<a href="https://ru.wikipedia.org/wiki/%D0%90%D1%81%D0%BF%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" target="_blank" rel="noopener noreferrer">Аспектно-ориентированного программирования<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
(АОП). Они позволяют:</p> <ul><li>связывать дополнительную логику до/после выполнения метода</li> <li>преобразовать результат, возвращаемый из функции</li> <li>преобразовать исключение, вызванное функцией</li> <li>расширить базовое поведение функции</li> <li>полностью переопределять функцию в зависимости от конкретных условий (например, в целях кэширования)</li></ul> <h2 id="основы"><a href="#основы" class="header-anchor">#</a> Основы</h2> <p>Каждый перехватчик реализует метод <code>intercept()</code>, который принимает два аргумента. Первый - это экземпляр
<code>ExecutionContext</code> (точно такой же объект, как и для <a href="/guide/guards.html">guards</a>). Экземпляр <code>ExecutionContext</code> наследуется
от <code>ArgumentsHost</code>. Мы уже встречались с <code>ArgumentsHost</code> в главе о фильтрах исключений. Там мы видели, что это
обертка вокруг аргументов, которые были переданы исходному обработчику, и содержит различные массивы аргументов
в зависимости от типа приложения. Вы можете вернуться к главе <a href="/guide/exception-filters.html#аргументы-хоста">Фильтры исключений</a>
для получения дополнительной информации по этой теме.</p> <h2 id="контекст-исполнения"><a href="#контекст-исполнения" class="header-anchor">#</a> Контекст исполнения</h2> <p>Расширяя <code>ArgumentsHost</code>, <code>ExecutionContext</code> также добавляет несколько новых вспомогательных методов, которые предоставляют
дополнительную информацию о текущем процессе выполнения. Эти подробности могут быть полезны при создании более общих
перехватчиков, которые могут работать с широким набором контроллеров, методов и контекстов выполнения.
Подробнее о <code>ExecutionContext</code> <a href="/guide/fundamentals/execution-context.html">здесь</a>.</p> <h2 id="обработчик-вызовов"><a href="#обработчик-вызовов" class="header-anchor">#</a> Обработчик вызовов</h2> <p>Вторым аргументом является <code>CallHandler</code>. Интерфейс <code>CallHandler</code> реализует метод <code>handle()</code>, который вы можете использовать
для вызова метода обработчика маршрута в какой-то момент вашего перехватчика. Если вы не вызовете метод <code>handle()</code>
в вашей реализации метода <code>intercept()</code>, метод обработчика маршрута не будет выполнен вообще.</p> <p>Такой подход означает, что метод <code>intercept()</code> эффективно <strong>заворачивает</strong> поток запросов/ответов. В результате
вы можете реализовать пользовательскую логику <strong>до и после</strong> выполнения конечного обработчика маршрута. Понятно, что вы можете
написать код в методе <code>intercept()</code>, который выполняется <strong>до</strong> вызова <code>handle()</code>, но как повлиять на то, что происходит после?
Поскольку метод <code>handle()</code> возвращает <code>Observable</code>, мы можем использовать мощные операторы <a href="https://github.com/ReactiveX/rxjs" target="_blank" rel="noopener noreferrer">RxJS<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
для дальнейшего манипулирования ответом. Используя терминологию аспектно-ориентированного программирования, вызов обработчика
маршрута (т.е. вызов <code>handle()</code>) называется <a href="https://en.wikipedia.org/wiki/Pointcut" target="_blank" rel="noopener noreferrer">Pointcut<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, указывая на то, что это точка,
в которую вставляется наша дополнительная логика.</p> <p>Рассмотрим, например, входящий запрос <code>POST /cats</code>. Этот запрос предназначен для обработчика <code>create()</code>, определенного
внутри <code>CatsController</code>. Если на этом пути будет вызван перехватчик, не вызывающий метод <code>handle()</code>, метод <code>create()</code>
не будет выполнен. Как только <code>handle()</code> будет вызван (и его <code>Observable</code> будет возвращен), обработчик <code>create()</code> будет запущен.
И как только поток ответа будет получен через <code>Observable</code>, над потоком могут быть выполнены дополнительные операции,
а окончательный результат возвращен вызывающему методу.</p> <p class="demo">Hello this is &lt;demo-component&gt;123</p> <h2 id="детали-перехватчиков"><a href="#детали-перехватчиков" class="header-anchor">#</a> Детали перехватчиков</h2> <p>Первый случай использования, который мы рассмотрим, - это использование перехватчика для регистрации взаимодействия
с пользователем (например, для хранения вызовов пользователя, асинхронной диспетчеризации событий или вычисления временной метки).
Ниже показан простой <code>LoggingInterceptor</code>:</p> <div class="filename">logging.interceptor.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> NestInterceptor<span class="token punctuation">,</span> ExecutionContext<span class="token punctuation">,</span> CallHandler <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> tap <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">LoggingInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">NestInterceptor</span> <span class="token punctuation">{</span>
  <span class="token function">intercept</span><span class="token punctuation">(</span>context<span class="token operator">:</span> ExecutionContext<span class="token punctuation">,</span> next<span class="token operator">:</span> CallHandler<span class="token punctuation">)</span><span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Before...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> next
      <span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
        <span class="token function">tap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">After... </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> now<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">ms</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><code>NestInterceptor&lt;T, R&gt;</code> - это общий интерфейс, в котором <code>T</code> указывает тип <code>Observable&lt;T&gt;</code> (поддерживающего поток ответа),
а <code>R</code> - тип значения, обернутого <code>Observable&lt;R&gt;</code>.</p></blockquote> <blockquote><p>Перехватчики, такие как контроллеры, провайдеры, guards и так далее, могут <strong>инжектировать зависимости</strong> через свой <code>конструктор</code>.</p></blockquote> <p>Поскольку <code>handle()</code> возвращает RxJS <code>Observable</code>, у нас есть широкий выбор операторов, которые мы можем использовать
для манипулирования потоком. В примере выше мы использовали оператор <code>tap()</code>, который вызывает нашу анонимную функцию
логирования успешном завершении потока, но не вмешивается в цикл ответа.</p> <h2 id="привязка-перехватчиков"><a href="#привязка-перехватчиков" class="header-anchor">#</a> Привязка перехватчиков</h2> <p>Чтобы установить перехватчик, мы используем декоратор <code>@UseInterceptors()</code>, импортированный из пакета <code>@nestjs/common</code>.
Как и <a href="/guide/pipes.html">pipes</a> и <a href="/guide/guards.html">guards</a>, перехватчики могут быть применены на контроллер, метод или глобально.</p> <div class="filename">cats.controller.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">UseInterceptors</span></span><span class="token punctuation">(</span>LoggingInterceptor<span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsController</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><blockquote><p>Декоратор <code>@UseInterceptors()</code> импортируется из пакета <code>@nestjs/common</code>.</p></blockquote> <p>Используя приведенную выше конструкцию, каждый обработчик маршрутов, определенный в <code>CatsController</code>,
будет использовать <code>LoggingInterceptor</code>. Когда кто-то вызовет конечную точку <code>GET /cats</code>, вы увидите следующий
вывод в консоле:</p> <div class="language- extra-class"><pre class="language-text"><code>Before...
After... 1ms
</code></pre></div><p>Обратите внимание, что мы передали тип <code>LoggingInterceptor</code> (вместо экземпляра), оставив ответственность
за инстанцирование фреймворку и обеспечив внедрение зависимостей. Как и в случае с pipes, guards
и фильтрами исключений, мы также можем передавать экземпляр на месте:</p> <div class="filename">cats.controller.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token decorator"><span class="token at operator">@</span><span class="token function">UseInterceptors</span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatsController</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><p>Как уже упоминалось, приведенная выше конструкция прикрепляет перехватчик к каждому обработчику, объявленному
этим контроллером. Если мы хотим ограничить область действия перехватчика одним методом, мы просто применяем
декоратор на уровне <strong>метода</strong>.</p> <p>Чтобы установить глобальный перехватчик, мы используем метод <code>useGlobalInterceptors()</code> экземпляра приложения Nest:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token keyword">await</span> NestFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>AppModule<span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">useGlobalInterceptors</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Глобальные перехватчики используются во всем приложении, для каждого контроллера и каждого обработчика маршрутов.
С точки зрения инъекции зависимостей, глобальные перехватчики, зарегистрированные вне модуля (с помощью <code>useGlobalInterceptors()</code>,
как в примере выше), не могут инъектировать зависимости, поскольку это делается вне контекста любого модуля. Чтобы решить
эту проблему, вы можете установить перехватчик <strong>непосредственно из любого модуля</strong>, используя следующую конструкцию:</p> <div class="filename">app.module.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Module <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token constant">APP_INTERCEPTOR</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/core'</span><span class="token punctuation">;</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Module</span></span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      provide<span class="token operator">:</span> <span class="token constant">APP_INTERCEPTOR</span><span class="token punctuation">,</span>
      useClass<span class="token operator">:</span> LoggingInterceptor<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AppModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><blockquote><p>При использовании этого подхода для выполнения инъекции зависимостей для перехватчика,
обратите внимание, что независимо от модуля, в котором используется эта конструкция, перехватчик, по сути, является глобальным.
Где это должно быть сделано?
Выберите модуль в котором определен перехватчик (<code>LoggingInterceptor</code> в примере выше). Кроме того, <code>useClass</code> -
не единственный способ работы с регистрацией пользовательских провайдеров. Узнайте больше <a href="/guide/fundamentals/custom-providers.html">здесь</a>.</p></blockquote> <h2 id="маппинг-ответа"><a href="#маппинг-ответа" class="header-anchor">#</a> Маппинг ответа</h2> <p>Мы уже знаем, что <code>handle()</code> возвращает <code>Observable</code>. Этот поток содержит значение <strong>возвращенное</strong> из обработчика маршрута,
и поэтому мы можем легко изменить его с помощью оператора RxJS <code>map()</code>.</p> <blockquote><p>Функция response mapping не работает со специфической для библиотеки стратегией ответа (использование объекта <code>@Res()</code> напрямую запрещено).
Давайте создадим <code>TransformInterceptor</code>, который будет тривиальным образом изменять каждый ответ для демонстрации процесса.
Он будет использовать оператор RxJS <code>map()</code> для присвоения объекта ответа свойству <code>data</code> вновь созданного объекта,
возвращая новый объект клиенту.</p></blockquote> <div class="filename">transform.interceptor.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> NestInterceptor<span class="token punctuation">,</span> ExecutionContext<span class="token punctuation">,</span> CallHandler <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> map <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">Response<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  data<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">TransformInterceptor<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">NestInterceptor<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Response<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token function">intercept</span><span class="token punctuation">(</span>context<span class="token operator">:</span> ExecutionContext<span class="token punctuation">,</span> next<span class="token operator">:</span> CallHandler<span class="token punctuation">)</span><span class="token operator">:</span> Observable<span class="token operator">&lt;</span>Response<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> next<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>data <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> data <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>Перехватчики Nest работают как с синхронными, так и с асинхронными методами <code>intercept()</code>. При необходимости
вы можете просто переключить метод на <code>async</code>.</p></blockquote> <p>При описанной выше конструкции, когда кто-то вызывает конечную точку <code>GET /cats</code>, ответ будет выглядеть следующим образом
(при условии, что обработчик маршрута возвращает пустой массив <code>[]</code>):</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;data&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Перехватчики имеют большое значение для создания повторно используемых решений для требований, которые встречаются
во всем приложении. Например, представьте, что нам нужно преобразовать каждое вхождение значения <code>null</code> в пустую
строку <code>''</code>. Мы можем сделать это с помощью одной строки кода и привязать перехватчик глобально, чтобы он автоматически
использовался каждым зарегистрированным обработчиком.</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> NestInterceptor<span class="token punctuation">,</span> ExecutionContext<span class="token punctuation">,</span> CallHandler <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Observable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> map <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ExcludeNullInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">NestInterceptor</span> <span class="token punctuation">{</span>
  <span class="token function">intercept</span><span class="token punctuation">(</span>context<span class="token operator">:</span> ExecutionContext<span class="token punctuation">,</span> next<span class="token operator">:</span> CallHandler<span class="token punctuation">)</span><span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> next
      <span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>value <span class="token operator">=&gt;</span> value <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token string">''</span> <span class="token operator">:</span> value <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="маппинг-исключении"><a href="#маппинг-исключении" class="header-anchor">#</a> Маппинг исключений</h2> <p>Еще один интересный случай использования - воспользоваться преимуществами оператора <code>catchError()</code> в RxJS для переопределения
брошенных исключений:</p> <div class="filename">errors.interceptor.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>
  Injectable<span class="token punctuation">,</span>
  NestInterceptor<span class="token punctuation">,</span>
  ExecutionContext<span class="token punctuation">,</span>
  BadGatewayException<span class="token punctuation">,</span>
  CallHandler<span class="token punctuation">,</span>
<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Observable<span class="token punctuation">,</span> throwError <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> catchError <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ErrorsInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">NestInterceptor</span> <span class="token punctuation">{</span>
  <span class="token function">intercept</span><span class="token punctuation">(</span>context<span class="token operator">:</span> ExecutionContext<span class="token punctuation">,</span> next<span class="token operator">:</span> CallHandler<span class="token punctuation">)</span><span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> next
      <span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
        <span class="token function">catchError</span><span class="token punctuation">(</span>err <span class="token operator">=&gt;</span> <span class="token function">throwError</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BadGatewayException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="переопределение-потоков"><a href="#переопределение-потоков" class="header-anchor">#</a> Переопределение потоков</h2> <p>Существует несколько причин, по которым мы иногда можем захотеть полностью отказаться от вызова обработчика и вернуть
вместо него другое значение. Очевидный пример - реализация кэша для улучшения времени отклика. Давайте рассмотрим
простой <strong>перехватчик кэша</strong>, который возвращает свой ответ из кэша. В реалистичном примере мы бы хотели рассмотреть
другие факторы, такие как TTL, аннулирование кэша, размер кэша и т.д., но это выходит за рамки данного обсуждения.
Здесь мы приведем базовый пример, демонстрирующий основную концепцию.</p> <div class="filename">cache.interceptor.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> NestInterceptor<span class="token punctuation">,</span> ExecutionContext<span class="token punctuation">,</span> CallHandler <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Observable<span class="token punctuation">,</span> <span class="token keyword">of</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CacheInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">NestInterceptor</span> <span class="token punctuation">{</span>
  <span class="token function">intercept</span><span class="token punctuation">(</span>context<span class="token operator">:</span> ExecutionContext<span class="token punctuation">,</span> next<span class="token operator">:</span> CallHandler<span class="token punctuation">)</span><span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> isCached <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isCached<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> next<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Наш <code>CacheInterceptor</code> имеет жестко заданную переменную <code>isCached</code> и жестко заданный ответ <code>[]</code>. Ключевым моментом
является то, что мы возвращаем новый поток, созданный оператором RxJS <code>of()</code>, поэтому обработчик маршрута
<strong>не будет вызван</strong> вообще. Когда кто-то вызывает конечную точку, использующую <code>CacheInterceptor</code>, ответ
(жестко закодированный, пустой массив) будет возвращен немедленно. Чтобы создать универсальное решение, вы можете
воспользоваться <code>Reflector</code> и создать собственный декоратор. Декоратор <code>Reflector</code> хорошо описан в главе <a href="/guide/guards.html">guards</a>.</p> <h2 id="больше-операторов"><a href="#больше-операторов" class="header-anchor">#</a> Больше операторов</h2> <p>Возможность манипулирования потоком с помощью операторов RxJS дает нам множество возможностей. Давайте рассмотрим еще
один распространенный случай использования. Представьте, что вы хотите обрабатывать <strong>таймауты</strong> в маршрутных запросах.
Когда ваша конечная точка ничего не возвращает по истечении определенного времени, вы хотите завершить запрос ответом
об ошибке. Следующая конструкция позволяет это сделать:</p> <div class="filename">timeout.interceptor.ts</div> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Injectable<span class="token punctuation">,</span> NestInterceptor<span class="token punctuation">,</span> ExecutionContext<span class="token punctuation">,</span> CallHandler<span class="token punctuation">,</span> RequestTimeoutException <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Observable<span class="token punctuation">,</span> throwError<span class="token punctuation">,</span> TimeoutError <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> catchError<span class="token punctuation">,</span> timeout <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'rxjs/operators'</span><span class="token punctuation">;</span>
<span class="token decorator"><span class="token at operator">@</span><span class="token function">Injectable</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">TimeoutInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">NestInterceptor</span> <span class="token punctuation">{</span>
  <span class="token function">intercept</span><span class="token punctuation">(</span>context<span class="token operator">:</span> ExecutionContext<span class="token punctuation">,</span> next<span class="token operator">:</span> CallHandler<span class="token punctuation">)</span><span class="token operator">:</span> Observable<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> next<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
      <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">catchError</span><span class="token punctuation">(</span>err <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>err <span class="token keyword">instanceof</span> <span class="token class-name">TimeoutError</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token function">throwError</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RequestTimeoutException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">throwError</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>По истечении 5 секунд обработка запроса будет отменена. Вы также можете добавить пользовательскую логику перед
выбросом <code>RequestTimeoutException</code> (например, освобождение ресурсов).</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/guide/guards.html" class="prev">
        Guards
      </a></span> <span class="next"><a href="/guide/custom-decorators.html">
        Пользовательские декораторы
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5b148a01.js" defer></script><script src="/assets/js/2.94dc10f7.js" defer></script><script src="/assets/js/17.62b50bbf.js" defer></script><script src="/assets/js/9.f5513680.js" defer></script>
  </body>
</html>
