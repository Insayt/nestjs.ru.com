(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{416:function(t,s,n){"use strict";n.r(s);var a=n(54),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"события-жизненного-цикла"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#события-жизненного-цикла"}},[t._v("#")]),t._v(" События жизненного цикла")]),t._v(" "),n("p",[t._v("Приложение Nest, как и каждый элемент приложения, имеет жизненный цикл, управляемый Nest. Nest предоставляет\n"),n("strong",[t._v("хуки жизненного цикла")]),t._v(", которые обеспечивают видимость ключевых событий жизненного цикла и возможность действовать\n(запускать зарегистрированный код в вашем "),n("code",[t._v("модуле")]),t._v(", "),n("code",[t._v("инжектере")]),t._v(" или "),n("code",[t._v("контроллере")]),t._v("), когда они происходят.")]),t._v(" "),n("h2",{attrs:{id:"последовательность-жизненного-цикла"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#последовательность-жизненного-цикла"}},[t._v("#")]),t._v(" Последовательность жизненного цикла")]),t._v(" "),n("p",[t._v("На следующей диаграмме показана последовательность ключевых событий жизненного цикла приложения, начиная с момента\nзагрузки приложения и заканчивая завершением процесса. Мы можем разделить общий жизненный цикл на три фазы:\n"),n("strong",[t._v("инициализация")]),t._v(", "),n("strong",[t._v("запуск")]),t._v(" и "),n("strong",[t._v("завершение")]),t._v(". Используя этот жизненный цикл, вы можете планировать соответствующую\nинициализацию модулей и служб, управлять активными соединениями и изящно завершать работу приложения, когда оно получает\nсигнал о завершении.")]),t._v(" "),n("img",{attrs:{src:"/lifecycle-events.png"}}),t._v(" "),n("h2",{attrs:{id:"события-жизненного-цикла-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#события-жизненного-цикла-2"}},[t._v("#")]),t._v(" События жизненного цикла")]),t._v(" "),n("p",[t._v("События жизненного цикла происходят во время загрузки и завершения приложения. Nest вызывает зарегистрированные методы\nlifecycle hook на "),n("code",[t._v("модулях")]),t._v(", "),n("code",[t._v("инжектах")]),t._v(" и "),n("code",[t._v("контроллерах")]),t._v(" при каждом из следующих событий жизненного цикла ("),n("strong",[t._v("shutdown hooks")]),t._v("\nдолжны быть сначала включены, как описано "),n("a",{attrs:{href:"/guide/fundamentals/lifecycle-events#application-shutdown"}},[t._v("ниже")]),t._v(").\nКак показано на диаграмме выше, Nest также вызывает соответствующие базовые методы для начала прослушивания соединений\nи для прекращения прослушивания соединений.")]),t._v(" "),n("p",[t._v("В следующей таблице "),n("code",[t._v("onModuleDestroy")]),t._v(", "),n("code",[t._v("beforeApplicationShutdown")]),t._v(" и "),n("code",[t._v("onApplicationShutdown")]),t._v(" срабатывают только если\nвы явно вызовете "),n("code",[t._v("app.close()")]),t._v(" или если процесс получит специальный системный сигнал (например, SIGTERM) и вы правильно\nвызвали "),n("code",[t._v("enableShutdownHooks")]),t._v(" при загрузке приложения (см. ниже "),n("strong",[t._v('Часть "Выключение приложения')]),t._v('").')]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("Хуки жизненного цикла")]),t._v(" "),n("th",[t._v("Событие жизненного цикла, инициирующее вызов хука")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[n("code",[t._v("onModuleInit()")])]),t._v(" "),n("td",[t._v("Вызывается после разрешения зависимостей главного модуля.")])]),t._v(" "),n("tr",[n("td",[n("code",[t._v("onApplicationBootstrap()")])]),t._v(" "),n("td",[t._v("Вызывается после инициализации всех модулей, но до прослушивания соединений.")])]),t._v(" "),n("tr",[n("td",[n("code",[t._v("onModuleDestroy()")]),t._v("*")]),t._v(" "),n("td",[t._v("Вызывается после получения сигнала завершения (например, "),n("code",[t._v("SIGTERM")]),t._v(").")])]),t._v(" "),n("tr",[n("td",[n("code",[t._v("beforeApplicationShutdown()")]),t._v("*")]),t._v(" "),n("td",[t._v("Вызывается после завершения всех обработчиков "),n("code",[t._v("onModuleDestroy()")]),t._v(" (Promises resolved or rejected);"),n("br"),t._v("после завершения (Promises resolved or rejected) все существующие соединения будут закрыты (вызывается "),n("code",[t._v("app.close()")]),t._v(").")])]),t._v(" "),n("tr",[n("td",[n("code",[t._v("onApplicationShutdown()")]),t._v("*")]),t._v(" "),n("td",[t._v("Вызывается после закрытия соединений (резолвится промис "),n("code",[t._v("app.close()")]),t._v(").")])])])]),t._v(" "),n("p",[t._v("* Для этих событий, если вы не вызываете "),n("code",[t._v("app.close()")]),t._v(" явно, вы должны сделать выбор, чтобы они работали с системными сигналами,\nтакими как "),n("code",[t._v("SIGTERM")]),t._v(". Смотрите "),n("a",{attrs:{href:"/guide/fundamentals/lifecycle-events#application-shutdown"}},[t._v("Завершение работы приложения")]),t._v(" ниже.")]),t._v(" "),n("blockquote",[n("p",[t._v("Перечисленные выше хуки жизненного цикла не срабатывают для классов "),n("strong",[t._v("привязанных к запросам")]),t._v(". Классы, привязанные\nк запросу, не привязаны к жизненному циклу приложения, и их продолжительность жизни непредсказуема.\nОни создаются исключительно для каждого запроса и автоматически очищаются от мусора после отправки ответа.")])]),t._v(" "),n("h2",{attrs:{id:"использование"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#использование"}},[t._v("#")]),t._v(" Использование")]),t._v(" "),n("p",[t._v("Каждый хук жизненного цикла представлен интерфейсом. Интерфейсы технически необязательны, поскольку они не существуют\nпосле компиляции TypeScript. Тем не менее, их использование является хорошей практикой, чтобы воспользоваться преимуществами\nсильной типизации и инструментария редактора. Чтобы зарегистрировать хук жизненного цикла, реализуйте соответствующий\nинтерфейс. Например, чтобы зарегистрировать метод, который будет вызываться во время инициализации модуля на определенном\nклассе (например, Controller, Provider или Module), реализуйте интерфейс "),n("code",[t._v("OnModuleInit")]),t._v(", предоставив метод "),n("code",[t._v("onModuleInit()")]),t._v(",\nкак показано ниже:")]),t._v(" "),n("div",{staticClass:"language-typescript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-typescript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" Injectable"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" OnModuleInit "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@nestjs/common'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token decorator"}},[n("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Injectable")])]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UsersService")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("OnModuleInit")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("onModuleInit")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token template-string"}},[n("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("The module has been initialized.")]),n("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h2",{attrs:{id:"асинхронная-инициализация"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#асинхронная-инициализация"}},[t._v("#")]),t._v(" Асинхронная инициализация")]),t._v(" "),n("p",[t._v("Хуки "),n("code",[t._v("OnModuleInit")]),t._v(" и "),n("code",[t._v("OnApplicationBootstrap")]),t._v(" позволяют отложить процесс инициализации приложения (возвращая "),n("code",[t._v("Promise")]),t._v("\nили помечая метод как "),n("code",[t._v("async")]),t._v(" и "),n("code",[t._v("await")]),t._v(" асинхронного завершения метода в теле метода).")]),t._v(" "),n("div",{staticClass:"language-typescript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-typescript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("onModuleInit")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("Promise")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("fetch")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h2",{attrs:{id:"завершение-работы-приложения"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#завершение-работы-приложения"}},[t._v("#")]),t._v(" Завершение работы приложения")]),t._v(" "),n("p",[t._v("Хуки "),n("code",[t._v("onModuleDestroy()")]),t._v(", "),n("code",[t._v("beforeApplicationShutdown()")]),t._v(" и "),n("code",[t._v("onApplicationShutdown()")]),t._v(" вызываются на этапе завершения\nработы приложения (в ответ на явный вызов "),n("code",[t._v("app.close()")]),t._v(" или при получении системных сигналов, таких как SIGTERM, если\nэто предусмотрено). Эта возможность часто используется в "),n("a",{attrs:{href:"https://kubernetes.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Kubernetes"),n("OutboundLink")],1),t._v(" для управления жизненным\nциклом контейнеров, в "),n("a",{attrs:{href:"https://www.heroku.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Heroku"),n("OutboundLink")],1),t._v(" для dynos или подобных сервисов.")]),t._v(" "),n("p",[t._v("Слушатели хуков отключения потребляют системные ресурсы, поэтому по умолчанию они отключены. Чтобы использовать\nхуки отключения, вы "),n("strong",[t._v("должны включить слушателей")]),t._v(", вызвав "),n("code",[t._v("enableShutdownHooks()")]),t._v(":")]),t._v(" "),n("div",{staticClass:"language-typescript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-typescript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" NestFactory "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@nestjs/core'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" AppModule "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./app.module'")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("bootstrap")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" app "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" NestFactory"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("AppModule"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Начинаем прослушивать хуки отключения")]),t._v("\n  app"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("enableShutdownHooks")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" app"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("listen")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("3000")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("bootstrap")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("blockquote",[n("p",[t._v("Из-за присущих платформе ограничений, NestJS имеет ограниченную поддержку хуков выключения приложения в Windows. Вы можете\nожидать, что "),n("code",[t._v("SIGINT")]),t._v(" будет работать, а также "),n("code",[t._v("SIGBREAK")]),t._v(" и в некоторой степени "),n("code",[t._v("SIGHUP")]),t._v(" - "),n("a",{attrs:{href:"https://nodejs.org/api/process.html#process_signal_events",target:"_blank",rel:"noopener noreferrer"}},[t._v("подробнее"),n("OutboundLink")],1),t._v(".\nОднако "),n("code",[t._v("SIGTERM")]),t._v(' никогда не будет работать в Windows, потому что убийство процесса в диспетчере задач является безусловным,\n"т.е. нет способа для приложения обнаружить или предотвратить его". Вот '),n("a",{attrs:{href:"https://docs.libuv.org/en/v1.x/signal.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("соответствующая документация"),n("OutboundLink")],1),t._v("\nиз libuv, чтобы узнать больше о том, как "),n("code",[t._v("SIGINT")]),t._v(", "),n("code",[t._v("SIGBREAK")]),t._v(" и другие обрабатываются в Windows. Также смотрите\nдокументацию Node.js по "),n("a",{attrs:{href:"https://nodejs.org/api/process.html#process_signal_events",target:"_blank",rel:"noopener noreferrer"}},[t._v("Обработке сигнальных событий"),n("OutboundLink")],1)])]),t._v(" "),n("blockquote",[n("p",[n("code",[t._v("enableShutdownHooks")]),t._v(" потребляет память, запуская слушателей. В случаях, когда вы запускаете несколько приложений\nNest в одном процессе Node (например, при выполнении параллельных тестов с Jest), Node может пожаловаться на чрезмерное\nколичество процессов прослушивателей. По этой причине "),n("code",[t._v("enableShutdownHooks")]),t._v(" не включен по умолчанию. Помните об этом,\nесли вы запускаете несколько экземпляров в одном процессе Node.")])]),t._v(" "),n("p",[t._v("Когда приложение получает сигнал о завершении работы, оно будет вызывать любые зарегистрированные методы "),n("code",[t._v("onModuleDestroy()")]),t._v(",\n"),n("code",[t._v("beforeApplicationShutdown()")]),t._v(", затем "),n("code",[t._v("onApplicationShutdown()")]),t._v(" (в последовательности, описанной выше) с соответствующим\nсигналом в качестве первого параметра. Если зарегистрированная функция ожидает асинхронного вызова (возвращает обещание),\nNest не будет продолжать последовательность, пока промис не будет разрешен или отклонен.")]),t._v(" "),n("div",{staticClass:"language-typescript extra-class"},[n("pre",{pre:!0,attrs:{class:"language-typescript"}},[n("code",[n("span",{pre:!0,attrs:{class:"token decorator"}},[n("span",{pre:!0,attrs:{class:"token at operator"}},[t._v("@")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("Injectable")])]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UsersService")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("OnApplicationShutdown")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("onApplicationShutdown")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("signal"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("signal"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// например "SIGINT"')]),t._v("\n  "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("blockquote",[n("p",[t._v("Вызов "),n("code",[t._v("app.close()")]),t._v(" не завершает процесс Node, а только запускает хуки "),n("code",[t._v("onModuleDestroy()")]),t._v(" и "),n("code",[t._v("onApplicationShutdown()")]),t._v(",\nпоэтому если есть какие-то интервалы, долго выполняющиеся фоновые задачи и т.д., процесс не будет автоматически завершен.")])])])}),[],!1,null,null,null);s.default=e.exports}}]);